<!doctype html>
<html lang="en" ng-app="AngularGLApp" ng-controller="RootCtrl">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <title>AngularGL</title>
        <link rel="stylesheet" href="css/app.css"/>
        <script id="vertShaderDiff" type="x-shader/x-vertex">
            /*precision highp float;
            precision highp int;

            uniform mat4 modelMatrix;
            uniform mat4 modelViewMatrix;
            uniform mat4 projectionMatrix;
            uniform mat4 viewMatrix;
            uniform mat3 normalMatrix;
            uniform vec3 cameraPosition;

            attribute vec3 position;
            attribute vec3 normal;*/

            uniform vec3 color;
            uniform vec3 pointLightPosition;

            uniform float d;
            uniform float r;
            uniform float C;

            attribute vec3 aTangent;

            varying vec3 vColor;

            vec3 blend3 (in vec3 x) {
                vec3 y = vec3(1.0 - x * x);
                y = max(y, vec3(0));
                return y;
            }

            void main() {
                //float d = 2.0;
                //float r = 0.5;
                //float C = 4.0;
                //const float M = 8.0;
                //vec3 aTangent = vec3(1.0, 1.0, 0.0);
                //vec3 pointLightPosition = vec3(0.0, 0.0, 300.0);

                vec3 P = (modelViewMatrix * vec4(position, 1.0)).xyz;
                vec3 L = normalize(pointLightPosition - P);
                vec3 V = normalize(cameraPosition - P);
                vec3 H = L + V;
                vec3 N = normalMatrix * normal;
                vec3 T = normalMatrix * aTangent;
                float u = dot(T, H) * d;
                float w = dot(N, H);
                float e = r * u / w;
                float c = exp(-e * e);

                vec3 anis = color * vec3(c); /*hiliteColor * vec4(c.x, c.y, c.z, 1);*/

                if(u < 0.0) {
                    u = -u;
                }

                const float M = 8.0;//0.5 * u * d;

                vec3 cdiff = vec3(0, 0, 0);

                for (float n = 1.0; n < M; n+=1.0) {
                    float y = 2.0 * u / n - 1.0;
                    cdiff.xyz += blend3(vec3(C * (y - 0.75), C * (y - 0.5), C * (y - 0.25)));
                }
                vColor = cdiff + anis;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        </script>
        <script id="fragShaderDiff" type="x-shader/x-fragment">
            precision highp float;

            varying vec3 vColor;

            void main(void) {
                gl_FragColor = vec4(vColor, 1.0);
            }
        </script>
        <script id="rtVert" type="x-shader/x-vertex">
        precision highp float;
        precision highp int;

        uniform mat4 modelMatrix;
        uniform mat4 modelViewMatrix;
        uniform mat4 projectionMatrix;
        uniform mat4 viewMatrix;
        uniform mat3 normalMatrix;
        uniform vec3 cameraPosition;
        uniform vec3 color;
        uniform vec3 pointLightPosition;

        attribute vec3 position;
        attribute vec3 normal;
        
        varying vec4 texCoord[1];
        
        void main (void) {
           vec4 pos = vec4(position, 1.0);
           texCoord[0] = pos;
           gl_Position = projectionMatrix * modelViewMatrix * pos;
        }
        </script>
        <script id="rtFragA" type="x-shader/x-fragment">
        precision highp float;

        uniform vec3 cameraPosition;

        varying vec4 texCoord[1];

        struct SCamera {
            vec3 Position;
            vec3 Side;
            vec3 Up;
            vec3 View;
            vec2 Scale;
        };

        struct SRay {
            vec3 Origin;
            vec3 Direction;
        };

        /* Use these macros for switching between bounding box and sphere */
        #define USE_BOX_
        #define USE_SPHERE

        /* Camera position and orientation */
        SCamera Camera = SCamera(
            cameraPosition,             /* Position */
            vec3(0, 0, -1),             /* Side */
            vec3(0, 1, 0),              /* Up */
            -normalize(cameraPosition), /* View */
            vec2(1, 1)                  /* Scale */
        );

        /* Current time (may be used for morphing) */
        uniform float Time;

        /* Current light position */
        uniform vec3 pointLightPosition;

        /* Minimum and maximum point of bounding box (if we use box) */
        const vec3 BoxMinimum = vec3(-1000.0);    
        const vec3 BoxMaximum = vec3( 1000.0);

        /* Radius of bounding sphere (if we use sphere) */
        const float SphereRadius = 1000.0;                

        /* Some useful vector constants */
        const vec3 Zero  = vec3(0.0, 0.0, 0.0);
        const vec3 Unit  = vec3(1.0, 1.0, 1.0);
        const vec3 AxisX = vec3(1.0, 0.0, 0.0);
        const vec3 AxisY = vec3(0.0, 1.0, 0.0);
        const vec3 AxisZ = vec3(0.0, 0.0, 1.0);

        #define T 1.6180339887

        /* We use these macros to simplify function equation */
        #define X point.x
        #define Y point.y
        #define Z point.z

        float CalcFunction(in vec3 point) {
            /* You can enter here any expression in the form F(x, y, z) */
            return 2.0 - cos (X + T * Y) - cos (X - T * Y) - cos (Y + T * Z) -
                         cos (Y - T * Z) - cos (Z - T * X) - cos (Z + T * X);

            // Also try this: 
            //return cos(X) + cos(Y) + cos(Z);
        }

        #undef X
        #undef Y
        #undef Z

        /* Step for numerical estimation of a gradient */
        #define STEP 0.01

        vec3 CalcNormal(in vec3 point) {
            /* We calculate normal by numerical estimation of a gradient */
            float A = CalcFunction(point + AxisX * STEP) - CalcFunction(point - AxisX * STEP);
            float B = CalcFunction(point + AxisY * STEP) - CalcFunction(point - AxisY * STEP);
            float C = CalcFunction(point + AxisZ * STEP) - CalcFunction(point - AxisZ * STEP);

            return normalize(vec3(A, B, C));
        }

        bool IntersectBox(
            in SRay ray,        /* ray origin and direction */
            in vec3 minimum,    /* minimum point of a box */
            in vec3 maximum,    /* maximum point of a box */
            out float start,    /* time of 1st intersection */
            out float final     /* time of 2nd intersection */
        ) {
            vec3 OMIN = (minimum - ray.Origin) / ray.Direction;
            vec3 OMAX = (maximum - ray.Origin) / ray.Direction;
            vec3 MAX = max(OMAX, OMIN);
            vec3 MIN = min(OMAX, OMIN);

            final = min(MAX.x, min(MAX.y, MAX.z));
            start = max(max (MIN.x, 0.0), max(MIN.y, MIN.z));    

            return final > start;
        }

        bool IntersectSphere (
            in SRay ray,        /* ray origin and direction */
            in float radius,    /* sphere radius */
            out float start,    /* time of 1st intersection */
            out float final     /* time of 2nd intersection */
        ) {
            float A = dot(ray.Direction, ray.Direction);
            float B = dot(ray.Direction, ray.Origin);
            float C = dot(ray.Origin, ray.Origin) - radius * radius;
            float D = B * B - A * C;

            if(D > 0.0) {
                D = sqrt(D);
                start = max(0.0, (-B - D) / A);
                final = (-B + D) / A;
                return final > 0.0;
            }

            return false;
        }

        #define INTERVALS 200

        /*
         * Intersects ray with implicit surface.
         *
         * Function implements simple and computational expensive
         * algorithm. We divide a ray interval into small segments
         * and check each of them. The segment contains a root if
         * function changes a sign on its end points. For root
         * approximation linear interpolation is used. For more
         * advanced methods see:
         *
         * John C. Hart. "Ray Tracing Implicit Surfaces".
         * http://graphics.cs.uiuc.edu/~jch/papers/rtis-tr.pdf
         *
         * Jag Mohan Singh and P J Narayanan. "Real-Time Ray-Tracing
         * of Implicit Surfaces on the GPU". Technical Report:
         * IIIT/TR/2007/72
         */

        bool IntersectSurface (
            in SRay ray,    /* ray origin and direction */
            in float start, /* time when a ray enters a box */
            in float final, /* time when a ray leaves a box */
            out float val   /* time of ray-surface hit */
        ) {
            float step = (final - start) / float(INTERVALS);
            float time = start;
            vec3 point = ray.Origin + time * ray.Direction;
            float right, left = CalcFunction(point);
            for(int i = 0; i < INTERVALS; ++i) {
                time += step;
                point += step * ray.Direction;
                right = CalcFunction(point);
                if (left * right < 0.0) {
                    val = time + right * step / (left - right);
                    return true;
                }
                left = right;
            }
            return false;
        }

        /*
         * Generates primary ray for a current fragment.
         *
         * You can change camera state by setting function argument.
         * It can be used for stereo rendering (move camera left and
         * right for each fragment and tracing two primary rays) or
         * anti-aliasing.
         */

        SRay GenerateRay(in SCamera camera /* current camera state */) {
            vec2 coords = texCoord[0].xy * camera.Scale;

            vec3 direction = camera.View -
                             camera.Side * coords.x +
                             camera.Up * coords.y;

            return SRay(camera.Position, normalize(direction));
        }

        /* Phong material of surface */
        #define AMBIENT 1.0
        #define DIFFUSE 1.0
        #define SPECULAR 1.0
        #define SHININESS 64.0

        /* Small value for moving origin of shadow ray (see code) */
        #define EPSILON 0.01

        /* Use this macro to enable/disable shadows */

        #define SHADOWS_

        /* Computes lighting in an intersection point and its final color */

        vec3 Phong(
            in vec3 point,  /* intersection point with surface */
            in vec3 normal, /* normal to the surface in this point */
            in vec3 color   /* diffuse color in this point */
        ) {
            vec3 light = normalize(pointLightPosition - point);
            vec3 view = normalize(Camera.Position - point);

            vec3 refl = reflect(-view, normal);

            float diffuse = max(dot(light, normal), 0.0);
            float specular = pow(max(dot(refl, light), 0.0), SHININESS);

            #if defined(SHADOWS)
                SRay ray = SRay(point + light * EPSILON, light);
                float start, final, time;

                #if defined(USE_BOX)
                    if(IntersectBox(ray, BoxMinimum, BoxMaximum, start, final))
                #elif defined(USE_SPHERE)
                    if (IntersectSphere(ray, SphereRadius, start, final))
                #endif

                if(IntersectSurface(ray, start, final, time)) {
                    diffuse *= 0.25;
                }     
            #endif 

            return AMBIENT * Unit +
                   DIFFUSE * diffuse * color +
                   SPECULAR * specular * Unit;
        }

        ///////////////////////////////////////////////////////////////////////////////
        // Core ray tracing function

        vec3 Raytrace(in SRay ray) {
            vec3 result = Zero;

            float start, final, time;

            #if defined(USE_BOX)
                if (IntersectBox(ray, BoxMinimum, BoxMaximum, start, final))
            #elif defined(USE_SPHERE)
                if (IntersectSphere(ray, SphereRadius, start, final))
            #endif

            if (IntersectSurface(ray, start, final, time)) {
                vec3 point = ray.Origin + ray.Direction * time;
                vec3 normal = CalcNormal(point);
                vec3 color = (point - BoxMinimum) / (BoxMaximum - BoxMinimum);
                result = Phong(point, normal, color);
            }

            return result;
        }

        ///////////////////////////////////////////////////////////////////////////////
        // Shader entry point

        void main(void) {
            SRay ray = GenerateRay(Camera);

            gl_FragColor = vec4(Raytrace(ray), 1.0);
        }
        </script>
    </head>
    <body>
        <!-- Static navbar -->
        <div class="navbar navbar-default hidden" role="navigation">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="#">
                    <img src="img/logo.png" alt="AngularGL">
                </a>
            </div>
            <div class="navbar-collapse collapse">
                <ul class="nav navbar-nav hidden">
                    <li class="active"><a href="#">Link</a></li>
                    <li><a href="#">Link</a></li>
                    <li><a href="#">Link</a></li>
                    <li class="dropdown"><a href="#" class="dropdown-toggle" data-toggle="dropdown">Dropdown <b class="caret"></b></a><ul class="dropdown-menu">
                        <li><a href="#">Action</a></li>
                        <li><a href="#">Another action</a></li>
                        <li><a href="#">Something else here</a></li>
                        <li class="divider"></li>
                        <li class="dropdown-header">Nav header</li>
                        <li><a href="#">Separated link</a></li>
                        <li><a href="#">One more separated link</a></li>
                        </ul></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li ng-class="{ active: activePath=='prototype01' }"><a href="#/prototype01">Prototype 1</a></li>
                    <li ng-class="{ active: activePath=='prototype02' }"><a href="#/prototype02">Prototype 2</a></li>
                    <li ng-class="{ active: activePath=='prototype03' }"><a href="#/prototype03">Prototype 3</a></li>
                    <li ng-class="{ active: activePath=='threeJsExample' }"><a href="#/threeJsExample">Three.js Example</a></li>
                    <!--
<li><a href="#/navbar-static">Static top</a></li>
<li><a href="#/navbar-fixed">Fixed top</a></li>
-->
                </ul>
            </div><!--/.nav-collapse -->
        </div>
        <!-- View -->
        <div class="ng-view"></div>
        <!-- Scripts -->
        <script src="js/libs/angular/angular.js"></script>
        <script src="js/libs/angular/angular-route.js"></script>
        <script src="async.js"></script>
        <script src="js/libs/threejs/three.js"></script>
        <script src="js/libs/threejs/OrbitControls.js"></script>
        <script src="js/libs/threejs/Mirror.js"></script>
        <script src="js/libs/ui-bootstrap-tpls-0.11.2.min.js"></script>
        <script src="js/libs/moment-with-langs.min.js"></script>
        <script src="js/libs/underscore-min.js"></script>
        <script src="js/libs/underscore.string.min.js"></script>
        <script src="js/libs/angulargl/angulargl.js"></script>
        <!--
<script src="js/libs/angulargl/glMatrix-0.9.5.min.js"></script>
<script src="js/libs/threejs/three.min.js"></script>
<script src="js/libs/angulargl/angulargl-canvas.js"></script>
<script src="js/libs/angulargl/angulargl-objects.js"></script>
<script src="js/libs/angulargl/angulargl-buffers.js"></script>
<script src="js/libs/angulargl/angulargl-shaders.js"></script>
-->
        <script src="js/app.js"></script>
        <script src="js/services.js"></script>
        <script src="js/controllers.js"></script>
        <script src="js/filters.js"></script>
        <script src="js/directives.js"></script>
    </body>
</html>